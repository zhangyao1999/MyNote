**单例模式常见例子**
数据库连接，配置文件读取，应用程序的日志写入，网站的计数器

### 代码块
作用：用来初始化类，对象
**使用**
- 如果被修饰，只能用static 。也就是说只有静态代码块和构造代码块（类中）和普通代码块（方法中）。

**静态代码块**
格式：在java类中，使用static修饰{}。只能调用静态的结构。
```java
static {  
    System.out.println("静态代码块");  
}
```
**执行时机**:静态代码块在类被加载的时候就运行了，而且只运行一次，并且优先于==各种代码块以及构造函数==。如果一个类中有多个静态代码块，会按照书写顺序依次执行。
**作用**:例如项目启动需要加载的配置文件等资源，可以放入静态代码块中。

**非静态代码块**
格式：在类中，使用{}声明。
```java
{  
    System.out.println("构造代码块");  
}
```
**执行时机**:　构造代码块在创建对象时被调用，每次创建对象都会调用一次，但是优先于构造函数执行。需要注意的是，听名字我们就知道，构造代码块不是优先于构造函数执行，而是依托于构造函数，也就是说，如果你不实例化对象，构造代码块是不会执行的。如果存在多个构造代码块，则执行顺序按照书写顺序依次执行。
**作用**:构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。但是反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数）。做诸如统计创建对象的次数等功能

**普通代码块**
　　普通代码块和构造代码块的区别是，构造代码块是在类中定义的，而普通代码块是在方法体中定义的。且普通代码块的执行顺序和书写顺序一致。

**执行顺序**
静态代码块>构造代码块>构造函数>普通代码块
**父类和子类执行顺序**
先父后子 静态代码块内容先执行，接着执行父类构造代码块和构造方法，然后执行子类构造代码块和构造方法。

### 关键字 final

**作用**：
被final修饰的类不可以被继承
被final修饰的方法不可以被重写
被final修饰的变量不可以被改变

重点是第三句：
final修饰基本数据类型，值不可变  
final修饰引用数据类型，地址不可变，变量指向对象的内容可变。
```java
{  
    final Object[] objects = new Object[1];  
    objects[0] = new Object();  
    objects=  new Object[1];  // 这里编译过不去
}
```

**另外**
1 被final修饰的方法，JVM会尝试为之寻求内联，这对于提升Java的效率是非常重要的。因此，假如能确定方法不会被继承，那么尽量将方法定义为final的，(现在的java版本已经优化了)

2 被final修饰的常量，在编译阶段会存入调用类的常量池中，

3 **final修饰一个成员变量（属性），必须要显示初始化。** 这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中(或者某个代码块中)对这个变量赋初值。

```java
public class Study {  
    public final String a;  
  
    public Study() {  
        a = "123";  
    }  
  
    public Study(String b) {  
        a = b;  
    }  
  
}
```

```java

public class Study {  
    public final String a;  
  
    {  
        a = "123";  
    }  
  
    public Study() {  
    }  
  
    public Study(String b) {  
    }  
  
}

```

进阶: 被final修饰的常量在编译阶段会被放入常量池中

- final是用于定义常量的, 定义常量的好处是: 不需要重复地创建相同的变量. 而常量池是Java的一项重要技术, 由final修饰的变量会在编译阶段放入到调用类的常量池中.
- 请看下面这段演示代码. 这个示例是专门为了演示而设计的, 希望能方便大家理解这个知识点.

```java
public static void main(String[] args) {
    int n1 = 2019;          //普通变量
    final int n2 = 2019;    //final修饰的变量

    String s = "20190522";  
    String s1 = n1 + "0522";	//拼接字符串"20190512"
    String s2 = n2 + "0522";	

    System.out.println(s == s1);	//false
    System.out.println(s == s2);	//true
}
```

> 首先要介绍一点: 整数-127-128是默认加载到常量池里的, 也就是说如果涉及到-127-128的整数操作, 默认在编译期就能确定整数的值. 所以这里我故意选用数字2019(大于128), 避免数字默认就存在常量池中.

- 上面的代码运作过程是这样的:
- 首先根据final修饰的常量会在编译期放到常量池的原则, n2会在编译期间放到常量池中.
- 然后s变量所对应的"20190522"字符串会放入到字符串常量池中, 并对外提供一个引用返回给s变量.
- 这时候拼接字符串s1, 由于n1对应的数据没有放入常量池中, 所以s1暂时无法拼接, 需要等程序加载运行时才能确定s1对应的值.
- 但在拼接s2的时候, 由于n2已经存在于常量池, 所以可以直接与"0522"拼接, 拼接出的结果是"20190522". 这时系统会查看字符串常量池, 发现已经存在字符串20190522, 所以直接返回20190522的引用. 所以s2和s指向的是同一个引用, 这个引用指向的是字符串常量池中的20190522.

- 当程序执行时, n1变量才有具体的指向.
- 当拼接s1的时候, 会创建一个新的String类型对象, 也就是说字符串常量池中的20190522会对外提供一个新的引用.
- 所以当s1与s用"=="判断时, 由于对应的引用不同, 会返回false. 而s2和s指向同一个引用, 返回true.

> 总结: 这个例子想说明的是: 由于被final修饰的常量会在编译期进入常量池, 如果有涉及到该常量的操作, 很有可能在编译期就已经完成.

### 抽象类和抽象方法

**概念**
首先了解抽象方法，`public abstract void open();`。 抽象方法只有声明，没有具体的实现。java规定：如果一个类有抽象方法，则这个类为抽象类。抽象类必须要用abstract修饰。
- 抽象类不可实例化

- 抽象方法只能是public或者protected。因为如果是private，子类无法继承，也就不能实现该方法。默认不写是public

- 子类若继承于一个抽象类，必须实现父类的全部抽象方法，除非自己也是抽象类（此时子类和父类的抽象方法不可以同名）。

- 抽象类也可以有具体的方法，也可以完全不包含抽象方法（那该类还有必要设置为抽象类么？）

**abstract**
- abstract不能与final并列修饰同一个类。
- abstract 不能与private、static、final或native并列修饰同一个方法。
